<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Signals and Systems - Set 1</title>
    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 30px;
            line-height: 1.6;
            background: linear-gradient(270deg, #ff4b4b, #ff9800, #ffda44);
            background-size: 600% 600%;
            animation: bgAnimation 12s ease infinite;
            transition: background 0.3s, color 0.3s;
        }
        
        h2 {
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
        }
        /* Question container */
        
        .q-container {
            max-width: 700px;
            margin: 0 auto 25px auto;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .q-container:hover {
            transform: scale(1.03);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
        }
        /* Question button */
        
        .q-btn {
            width: 100%;
            padding: 14px 18px;
            border: none;
            background: rgba(229, 57, 53, 0.85);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 500;
            text-align: left;
            transition: background 0.3s, transform 0.2s;
            margin-bottom: 15px;
        }
        
        .q-btn:hover {
            background: rgba(183, 28, 28, 0.9);
            transform: translateY(-2px);
        }
        /* Answer box */
        
        .answer-box {
            display: none;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 12px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #fff;
            animation: fadeIn 0.5s;
        }
        
        .answer-box.active {
            display: block;
        }
        /* Light Mode */
        
        body.light {
            background: linear-gradient(270deg, #ffecd2, #fcb69f, #ffe29f);
            background-size: 600% 600%;
            animation: bgAnimationLight 12s ease infinite;
            color: #333;
        }
        
        body.light h2 {
            color: #222;
        }
        
        body.light .q-container {
            background: rgba(255, 255, 255, 0.6);
            color: #000;
        }
        
        body.light .answer-box {
            background: rgba(255, 255, 255, 0.8);
            color: #000;
        }
        /* Dark Mode */
        
        body.dark {
            background: linear-gradient(270deg, #000000, #8b0000, #000000);
            background-size: 400% 400%;
            animation: bgAnimationDark 10s ease infinite;
            color: #eee;
        }
        
        body.dark h2 {
            color: #fff;
        }
        
        body.dark .q-container {
            background: rgba(30, 30, 30, 0.6);
        }
        
        body.dark .answer-box {
            background: rgba(50, 50, 50, 0.8);
        }
        /* Animations */
        
        @keyframes bgAnimationLight {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        
        @keyframes bgAnimationDark {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        /* Theme Toggle Button */
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 18px;
            background: #ff5722;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.3s, transform 0.2s;
            z-index: 1000;
        }
        
        .theme-toggle:hover {
            background: #e90505;
            transform: scale(1.05);
        }
        /* Animations */
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes bgAnimation {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
    </style>
</head>

<body class="dark">
    <button class="theme-toggle" id="themeBtn">‚òÄÔ∏è Light Mode</button>
    <h2>Signals and Systems - Set 2</h2>

    <!-- Q&A blocks -->
    <div class="q-container">
        <button class="q-btn" onclick="toggleAnswer(0)">Q1: What is the difference between an in-place and out-of-place sorting algorithm? Give one example of each. </button>
        <div class="answer-box">
            <p><b>Answer:</b></p>
            <p>An in-place algorithm sorts the array by modifying it directly, requiring only a constant O(1) amount of extra memory.</p>
            <p>Example: Bubble Sort, Quick Sort, or Heap Sort.</p>
            <p>An out-of-place algorithm requires extra memory, typically proportional to the input size O(n), to store the sorted elements. Example: Merge Sort.</p>
        </div>
    </div>

    <div class="q-container">
        <button class="q-btn" onclick="toggleAnswer(1)">Q2: What does it mean for a sorting algorithm to be ‚Äústable‚Äù?</button>
        <div class="answer-box">
            <p><b>Answer:</b></p>
            <p>A sorting algorithm is stable if it maintains the original relative order of elements that have equal values. </p>
            <p>For instance, if two identical elements A and B appear in that order in the input, they will also appear as A then B in the sorted output.</p>
        </div>
    </div>

    <div class="q-container">
        <button class="q-btn" onclick="toggleAnswer(2)">Q3: Why is Insertion Sort a good choice for an array that is already ‚Äúnearly sorted‚Äù?</button>
        <div class="answer-box">
            <p><b>Answer:</b></p>
            <p>Insertion Sort‚Äôs performance is adaptive. For each element, it checks backwards until it finds the correct position. </p>
            <p>In a nearly sorted array, the correct position is very close to the current one. This means it only needs to perform a 
                few comparisons and shifts for each element, making its time complexity approach the best-case O(n), 
                which is much faster than the guaranteed O(n log n) of Merge Sort or Quick Sort for the same scenario.</p>
           
        </div>
    </div>

    <div class="q-container">
        <button class="q-btn" onclick="toggleAnswer(3)">Q4: What is the worst-case scenario for Quick Sort, and what is its time complexity in that case?</button>
        <div class="answer-box">
            <p><b>Answer:</b></p>
            <p>The worst-case for Quick Sort occurs when the chosen pivot is consistently the smallest or largest element in the partition. </p>
            <p>This leads to highly unbalanced sub-arrays (one of size 0 and the other of size n-1).</p>
            <p>This commonly happens if the array is already sorted or reverse-sorted and the first or last element is chosen as the pivot. In this scenario, the time complexity degrades to O(n¬≤).</p>
            
        </div>
    </div>

    <div class="q-container">
        <button class="q-btn" onclick="toggleAnswer(4)">Q5: Between Quick Sort and Merge Sort, which is generally better for sorting arrays in C and why?</button>
        <div class="answer-box">
            <p><b>Answer:</b></p>
            <p>Quick Sort is generally preferred for sorting arrays in C.
               In-Place Sorting: It sorts the array in-place, requiring only O(log n) auxiliary space for the recursion stack. Merge Sort requires O(n) extra space for a temporary array, which can be a significant overhead.</p>
            <p>Cache Performance: Quick Sort exhibits better locality of reference. Because it works on contiguous blocks of memory, it utilizes the CPU cache more effectively than Merge Sort, often resulting in faster practical performance despite having the same average-case time complexity.</p>
        </div>
    </div>

    <script>
        const answers = document.querySelectorAll(".answer-box");
        const themeBtn = document.getElementById("themeBtn");

        function toggleAnswer(index) {
            answers[index].classList.toggle("active");
        }

        // Dark/Light Theme Toggle
        themeBtn.addEventListener("click", () => {
            if (document.body.classList.contains("dark")) {
                document.body.classList.remove("dark");
                document.body.classList.add("light");
                themeBtn.textContent = "üåô Dark Mode";
            } else {
                document.body.classList.remove("light");
                document.body.classList.add("dark");
                themeBtn.textContent = "‚òÄÔ∏è Light Mode";
            }
        });
    </script>
</body>

</html>